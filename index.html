---

layout: default
title: Un lenguaje de patrón para microservicios

---

<section id="top" class="one dark cover center">
	<div class="container">

		<header>
			<h2 class="alt">Un <a href="https://es.wikipedia.org/wiki/Lenguaje_de_patr%C3%B3n">lenguaje de patrón</a> para microservicios.</h2>
			<p>Contenido original de Chris Richardson,<br/>
				traducido al español.</p>
		</header>

		<footer>
			<a href="http://microservices.io/patterns/index.html" class="button scrolly">Ver el contenido original</a>
		</footer>

	</div>
</section>

<section id="intro" class="two center">
	<div class="container">
		<header>
			<h2>¿Qué son los microservicios?</h2>
		</header>

		<p class="center">
			Los microservicios (también conocidos como arquitectura de microservicios) son un estilo arquitectónico que estructura 
				una aplicación como un conjunto de servicios sin conexión directa, que implementan capacidades empresariales. La 
				arquitectura de microservicios permite la entrega/despliegue continuo de aplicaciones grandes y complejas. También 
				permite a una organización evolucionar su pila tecnológica.
		</p>
	</div>
</section>

<section id="contents" class="three">
	<div class="container">
		<header class="center">
			<h2>Indice de contenidos</h2>
		</header>

		<a href="http://microservices.io/i/MicroservicePatternLanguage.jpg" target="_blank" class="image featured"><img src="http://microservices.io/i/MicroservicePatternLanguage.jpg" alt="Mapa para la implementación de microservicios" /></a>

		<p class="center">A continuación se listan los artículos por categorías, según la pregunta que se intenta contestar. Para mejor entendimiento, ver el mapa <i class="fas fa-up"></i></p>

		<h3 id="core-patterns">Patrones base</h3>
		<hr/>
		<blockquote>¿Cuál arquitectura deberías elegir para desarrollar una aplicación?</blockquote>
		<ul class="default">
			<li><a href="core-patterns/monolithic.html"><b>Monolítico</b></a> - diseña la aplicación como una unidad desplegable individual.</li>
			<li><a href="core-patterns/microservices.html"><b>Microservicios</b></a> - diseña la aplicación como una colección de servicios ligeramente acoplados.</li>
		</ul>

		<h3 id="decomposition">Descomposición</h3>
		<hr/>
		<blockquote>¿Cómo descomponer la aplicación en servicios?</blockquote>
		<ul class="default">
			<li><a href="decomposition/decompose-by-business-capability.html"><b>Descomponer por capacidades del negocio</b></a> - define los servicios de acuerdo a las capacidades del negocio.</li>
			<li><a href="decomposition/decompose-by-subdomain.html"><b>Descomponer por subdominios</b></a> - define los servicios de acuerdo a subdominios del modelo de dominio (Domain Driven Design)</li>
		</ul>

		<h3 id="deployment-patterns">Patrones de despliegue</h3>
		<hr/>
		<blockquote>¿Cómo desplegar los servicios de la aplicación?</blockquote>
		<ul class="default">
			<li><a href="deployment/multiple-services-per-host.html"><b>Múltiples instancias de servicios por host</b></a> - despliega múltiples instancias de servicios en un sólo host.</li>
			<li><a href="deployment/single-service-per-host.html"><b>Una instancia de servicio por host</b></a> - despliega cada instancia de servicio en su propio host.</li>
			<li><a href="deployment/service-per-vm.html"><b>Una instancia de servicio por máquina virtual</b></a> - despliega cada instancia de servicio en su propia máquina virtual.</li>
			<li><a href="deployment/service-per-container.html"><b>Una instancia de servicio por contenedor</b></a> - despliega cada instancia de servicio en su propio contenedor.</li>
			<li><a href="/patterns/deployment/serverless-deployment.html"><b>Despliegue sin servidor (BaaS)</b></a> - despliega un servicio en una plataforma de "BaaS" (Backend-As-A-Service).</li>
			<li><a href="/patterns/deployment/service-deployment-platform.html"><b>Plataforma de despliegue de servicios</b></a> - despliega servicios usando una plataforma de despliegue altamente automatizada que provee abstracción de servicios.</li>
		</ul>

		<h3 id="cross-cutting-concerns">Intereses transversales</h3>
		<hr/>
		<blockquote>¿Cómo manejar los intereses transversales?</blockquote>
		<ul class="default">
			<li><a href="/patterns/microservice-chassis.html"><b>Chasis de microservicios</b></a> - un framework que maneja intereses transversales y simplifica el desarrollo de servicios.</li>
			<li><a href="/patterns/externalized-configuration.html"><b>Externalized configuration</b></a> - externaliza todas las configuraciones, como la dirección de la base de datos, y credenciales</li>
		</ul>

		<h3 id="communication-patterns">Patrones de comunicación</h3>
		<hr/>

		<h4 id="style">Estilo</h4>
		<blockquote>¿Qué mecanismos de comunicación usan los servicios para comunicarse entre ellos y con sus clientes externos?</blockquote>
		<ul class="default">
			<li><a href="communication-style/rpi.html"><b>Llamada a procedimiento remoto</b></a> - usa un protocolo orientado a RPC para la comunicación entre servicios.</li>
			<li><a href="communication-style/messaging.html"><b>Mensajería</b></a> - usa mensajes asíncronos para la comunicación entre servicios.</li>
			<li><a href="communication-style/domain-specific.html"><b>Protocolo específico del dominio</b></a> - usa un protocolo especificado por el dominio.</li>
		</ul>

		<h4 id="external-api">API Externa</h4>
		<blockquote>¿Cómo se comunican los clientes con los servicios?</blockquote>
		<ul class="default">
			<li><a href="apigateway.html"><b>API Gateway (Puerta de enlace)</b></a> - un servicio que provee a todos los clientes con una interfaz única hacia los servicios.</li>
			<li><a href="apigateway.html"><b>Backend para el front-end</b></a> - una puerta de enlace por cada tipo de cliente</li>
		</ul>

		<h4 id="service-discovery">Descubrimiento de servicios</h4>
		<blockquote>¿Cómo descubren la ubicación de red de una instancia los clientes de un servicio orientado a RPC?</blockquote>
		<ul class="default">
			<li><a href="client-side-discovery.html"><b>Descubrimiento en el lado del cliente</b></a> - el cliente consulta un registro de servicios para descubrir la ubicación de una instancia de servicio.</li>
			<li><a href="server-side-discovery.html"><b>Descubrimiento en el lado del servidor</b></a> - un enrutador consulta un registro de servicios para descubrir la ubicación de una instancia de servicio.</li>
			<li><a href="service-registry.html"><b>Registro de servicios</b></a> - una base de datos para las ubicaciones de instancias de servicio.</li>
			<li><a href="self-registration.html"><b>Autoregistro</b></a> - una instancia de servicio se registra a sí misma en el registro de servicios.</li>
			<li><a href="3rd-party-registration.html"><b>Registro de terceros</b></a> - un tercero registra una instancia de servicio en el registro de servicios.</li>
		</ul>

		<h4 id="reliability">Confiabilidad</h4>
		<blockquote>¿Cómo prevenimos que la falla de un servicio afecte a los demás?</blockquote>
		<ul class="default">
			<li><a href="reliability/circuit-breaker.html"><b>Corta circuitos</b></a> - invoca un servicio remoto a través de un proxy, el cual falla inmediatamente cuando la tasa de fallos de la llamada remota excede un umbral.</li>
		</ul>

		<h3 id="data-management">Administración de datos</h3>
		<hr/>
		<blockquote>¿Cómo mantener la consistencia de datos e implementar las consultas?</blockquote>
		<ul class="default">
			<li><a href="data/database-per-service.html"><b>Base de datos por servicio</b></a> - cada servicio tiene su propia base de datos privada.</li>
			<li><a href="data/shared-database.html"><b>Base de datos compartida</b></a> - los servicios comparten una o más bases de datos.</li>
			<li><a href="data/saga.html"><b>Saga</b></a> - usa sagas, secuencias de transacciones locales, para mantener consistencia de datos entre servicios.</li>
			<li><a href="data/api-composition.html"><b>Composición de API</b></a> - implementa consultas invocando los servicios que poseen los datos y la realiza una unión en memoria.</li>
			<li><a href="data/cqrs.html"><b>Separación de responsabilidad de comandos y consultas (CQRS)</b></a> - implementa consultas manteniendo una o más vistas que pueden ser consultadas eficientemente.</li>
			<li><a href="data/event-sourcing.html"><b>Event Sourcing</b></a> - almacena conjuntos como una secuencia de eventos.</li>
			<li><a href="data/transaction-log-tailing.html"><b>Transaction log tailing</b></a> - publica como mensajes los cambios registrados en el historial de transacciones de la base de datos.</li>
			<li><a href="data/database-triggers.html"><b>Triggers en la base de datos</b></a> - usa triggers para capturar la modificación de los datos.</li>
			<li><a href="data/application-events.html"><b>Eventos de aplicación</b></a> - la aplicación inserta eventos en una tabla de base de datos que es usada como cola de mensajes.</li>
		</ul>

		<h3 id="security">Seguridad</h3>
		<hr/>
		<blockquote>¿Cómo comunicar la identidad del solicitante a los servicios que manejan la solicitud?</blockquote>
		<ul class="default">
			<li><a href="security/access-token.html"><b>Token de acceso</b></a> - un token seguro con información del usuario que es intercambiado entre servicios.</li>
		</ul>

		<h3 id="testing">Pruebas</h3>
		<hr/>
		<blockquote>¿Cómo realizar pruebas de forma sencilla?</blockquote>
		<ul class="default">
			<li><a href="testing/service-component-test.html"><b>Prueba de componentes del servicio</b></a> - un plan de pruebas que evalúa un servicio de forma aislada utilizando imitaciones para todos los servicios que este invoca.</li>
			<li><a href="testing/service-integration-contract-test.html"><b>Prueba del contrato para la integración de servicios</b></a> - un plan de pruebas para evaluar la integración con un servicio externo.</li>
		</ul>

		<h3 id="observability">Observabilidad</h3>
		<hr/>
		<blockquote>¿Cómo entender el comportamiento de una aplicación y resolver problemas?</blockquote>
		<ul class="default">
			<li><a href="observability/application-logging.html"><b>Colección de logs</b></a> - agrupa los logs de las aplicaciones</li>
			<li><a href="observability/application-metrics.html"><b>Métricas de la aplicación</b></a> - instrumentaliza el código de un servicio para recolectar estadísticas operativas.</li>
			<li><a href="observability/audit-logging.html"><b>Log de auditoría</b></a> - almacena la actividad de los usuarios en una base de datos.</li>
			<li><a href="observability/distributed-tracing.html"><b>Traza distribuida</b></a> - instrumentaliza los servicios con código que asigna a cada solicitud externa un identificador único
					que es pasado entre servicios. Almacena información acerca del trabajo realizado (por ej.: hora inicio, hora fin) cuando se maneje la solicitud
					en un servicio centralizado.</li>
			<li><a href="observability/exception-tracking.html"><b>Seguimiento de excepciones</b></a> - reporta todas las excepciones a un servicio de seguimiento centralizado que agrupa y rastrea
					excepciones y notifica a los desarrolladores.</li>
			<li><a href="observability/health-check-api.html"><b>API para verificación de estado</b></a> - API del servicio que retorna el estado de salud y que puede ser consultada para monitoreo.</li>
			<li><a href="/patterns/observability/log-deployments-and-changes.html"><b>Registro de despliegues y cambios</b></a></li>
		</ul>

		<h3 id="ui-patterns">Patrones de Interfaz de Usuario</h3>
		<hr/>
		<blockquote>¿Cómo implementar una interfaz de usuario que muestra datos desde múltiples servicios?</blockquote>
		<ul class="default">
			<li><a href="ui/server-side-page-fragment-composition.html"><b>Composición de fragmentos de página en el lado del servidor</b></a> - construye una página en el servidor mediante la composición de fragmentos HTML generados por múltiples 
					aplicaciones web específicas de los distintos subdominios/áreas del negocio.</li>
			<li><a href="ui/client-side-ui-composition.html"><b>Composición de la interfaz de usuario en el lado del cliente</b></a> - Construye la interfaz de usuario en el cliente mediante la composición de fragmentos de interfaz renderizados por múltiples
					componentes de interfaz de usuario específicos de los distintos subdominios/áreas del negocio.</li>
		</ul>

	</div>
</section>

<section id="about" class="two center">
	<div class="container">
		<header>
			<h2>Sobre el autor</h2>
		</header>

		<p class="center">
			<a href="http://www.chrisrichardson.net/about.html">Chris Richardson</a> es un arquitecto de software y empresario, con grado académico en Ciencias de la Computación de la 
			Universidad de Cambridge en Inglaterra. Es un gran desarrollador en Java y autor de "POJOs in Action",
			que describe cómo construir aplicaciones empresariales en Java con POJOs (<em>Plain Old Java Objects</em>) y frameworks,
			como Spring e Hibernate.
		</p>
		<p class="center">
			Chris es el fundador de la original CloudFoundry.com, una de las primeras PaaS (<em>Platform-As-A-Service</em>) de Java
			para Amazon EC2, que luego fue adquirida por SpringSource. También es el co-fundador de Component Systems LLC., una empresa de
			consultoría que se enfoca en la arquitectura de sistemas distribuidos de gran escala, y que fue adquirida por <a href="https://en.wikipedia.org/wiki/BEA_Systems">BEA Systems</a>.
		</p>
		<p class="center">
			Actualmente se dedica a la consultoría y a su startup <a href="http://eventuate.io/">eventuate.io</a>.
		</p>
	</div>
</section>